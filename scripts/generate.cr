require "json"
require "http/client"
require "code_writer"

METHODS_OUTPUT = File.expand_path(File.join(File.dirname(__FILE__), "../src/tourmaline/client/api.cr"))
TYPES_OUTPUT   = File.expand_path(File.join(File.dirname(__FILE__), "../src/tourmaline/types/api.cr"))

API_JSON_ENDPOINT = "https://raw.githubusercontent.com/PaulSonOfLars/telegram-bot-api-spec/master/api.min.json"

BANNER = <<-TEXT
# This file is auto-generated by the scripts/generate.cr script.
# Do not edit this file manually. Changes will be overwritten.
TEXT

class Api
  include JSON::Serializable

  property version : String

  property release_date : String

  property changelog : String

  property methods : Hash(String, Api::TypeDef)

  property types : Hash(String, Api::TypeDef)

  class TypeDef
    include JSON::Serializable

    property name : String

    property href : String

    property description : Array(String)

    property returns : Array(String) = [] of String

    property fields : Array(Api::Field) = [] of Api::Field

    property subtypes : Array(String) = [] of String

    property subtype_of : Array(String) = [] of String
  end

  class Field
    include JSON::Serializable

    property name : String

    property types : Array(String) = [] of String

    property required : Bool

    property description : String
  end
end

def get_spec
  spec = HTTP::Client.get(API_JSON_ENDPOINT)
  Api.from_json(spec.body)
end

def type_to_cr(type : String | Array(String))
  if type.is_a?(Array)
    return type.map(&->type_to_cr(String)).join(" | ")
  end

  if type.starts_with?("Array of ")
    return "Array(" + type_to_cr(type.sub("Array of ", "")) + ")"
  end

  case type
  when "Integer"
    "Int64"
  when "Float"
    "Float64"
  when "Boolean"
    "Bool"
  when "String"
    "String"
  when "InputFile"
    "::File"
  else
    "Tourmaline::#{type}"
  end
end

def write_methods(writer : CodeWriter, methods : Array(Api::TypeDef))
  writer.comment("Auto generated methods for the Telegram bot API.")
  writer.block("module Tourmaline") do
    writer.block("class Client") do
      writer.block("module Api") do
        methods.each do |method|
          write_method(writer, method)
          writer.newline
        end
      end
    end
  end
end

# Write a single method to the writer
def write_method(writer : CodeWriter, method : Api::TypeDef)
  method.description.each do |line|
    writer.comment(line)
  end

  # Sort the fields by requiredness. Required fields come first. Maintains order.
  fields = method.fields.sort_by { |f| f.required ? -1 : 1 }

  if fields.empty?
    writer.puts("def #{method.name.underscore}")
  else
    writer.puts("def #{method.name.underscore}(").indent do
      fields.each_with_index do |field, i|
        writer.print("#{field.name.underscore} : #{type_to_cr(field.types)}")
        if !field.required
          writer.print(" | ::Nil = nil")
        end

        if i < fields.size - 1
          writer.print(", ").newline
        end
      end
    end
    writer.newline.puts(")")
  end

  writer.indent do
    writer.print("request(#{type_to_cr(method.returns)}, \"#{method.name}\"")
    if fields.any?
      writer.puts(", {")
      writer.indent do
        fields.each_with_index do |field, i|
          writer.print("#{field.name.underscore}: #{field.name.underscore}")
          if i < fields.size - 1
            writer.print(", ").newline
          end
        end
      end
      writer.newline.puts("})")
    else
      writer.puts(")")
    end
  end

  writer.puts(writer.block_end)
end

def write_types(writer : CodeWriter, types : Array(Api::TypeDef))
  writer.comment("Auto generated types for the Telegram bot API.")
  writer.block("module Tourmaline") do
    types.each_with_index do |type, i|
      write_type(writer, type)
      writer.blank_line if i < types.size - 1
    end
  end
end

def write_type(writer : CodeWriter, type : Api::TypeDef)
  type.description.each do |line|
    writer.comment(line)
  end

  fields = type.fields.sort_by { |f| f.required ? -1 : 1 }

  if type.subtypes.any?
    writer.print "alias #{type.name} = "
    writer.print type.subtypes.map { |subtype| "Tourmaline::#{subtype}" }.join(" | ")
    writer.newline
    return
  end

  writer.block("class #{type.name}") do
    writer.print("include JSON::Serializable")
    writer.blank_line if fields.any?

    fields.each do |field|
      field_name = field.name.underscore

      writer.comment(field.description)

      crystal_type = type_to_cr(field.types)
      if crystal_type == "Bool"
        writer.print("property? #{field_name} : #{crystal_type}")
        writer.print(" | ::Nil") if !field.required
      elsif field.name =~ /\b(date|time)\b|_date$|_time$/i
        writer.puts("@[JSON::Field(converter: Time::EpochConverter)]")
        writer.print("property #{field_name} : Time")
        writer.print(" | ::Nil") if !field.required
      elsif crystal_type.starts_with?("Array(")
        writer.print("property #{field_name} : #{crystal_type}")
        # get the inner type
        inner_type = crystal_type.sub("Array(", "").sub(")", "")
        # if it isn't a primitive type, prepend the module name
        writer.print(" = [] of #{inner_type}")
      else
        writer.print("property #{field_name} : #{crystal_type}")
        writer.print(" | ::Nil") if !field.required
      end

      writer.newline
      writer.newline
    end

    if fields.any?
      writer.puts("def initialize(").indent do
        fields.each_with_index do |field, i|
          writer.print("@#{field.name.underscore} : #{type_to_cr(field.types)}")
          if !field.required
            writer.print(" | ::Nil = nil")
          end

          if i < fields.size - 1
            writer.print(", ").newline
          end
        end
      end
      writer.newline.puts(")")
      writer.puts(writer.block_end)
    end
  end
end

def main
  types_file = File.open(TYPES_OUTPUT, "w+")
  methods_file = File.open(METHODS_OUTPUT, "w+")

  types_writer = CodeWriter.new(buffer: types_file, tab_count: 2)
  methods_writer = CodeWriter.new(buffer: methods_file, tab_count: 2)

  spec = get_spec
  puts "Generating client for Telegram Bot API #{spec.version} (#{spec.release_date})"
  puts "Changelog: #{spec.changelog}"

  types_writer.puts BANNER
  types_writer.newline

  methods_writer.puts BANNER
  methods_writer.newline

  write_types(types_writer, spec.types.values)
  write_methods(methods_writer, spec.methods.values)
ensure
  types_file.try &.close
  methods_file.try &.close
end

main()
